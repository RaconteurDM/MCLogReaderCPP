\hypertarget{class_generic_reader}{}\doxysection{Generic\+Reader$<$ Source\+Encoding, Target\+Encoding, Stack\+Allocator $>$ Class Template Reference}
\label{class_generic_reader}\index{GenericReader$<$ SourceEncoding, TargetEncoding, StackAllocator $>$@{GenericReader$<$ SourceEncoding, TargetEncoding, StackAllocator $>$}}


SAX-\/style JSON parser. Use \mbox{\hyperlink{reader_8h_a84f3b66a66647f4ac4267078359188ba}{Reader}} for \mbox{\hyperlink{struct_u_t_f8}{UTF8}} encoding and default allocator.  




{\ttfamily \#include $<$reader.\+h$>$}

\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_generic_reader_ab39a92bb26d50aee6469df604622218a}\label{class_generic_reader_ab39a92bb26d50aee6469df604622218a}} 
typedef Source\+Encoding\+::\+Ch \mbox{\hyperlink{class_generic_reader_ab39a92bb26d50aee6469df604622218a}{Ch}}
\begin{DoxyCompactList}\small\item\em Source\+Encoding character type. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_generic_reader_aab875a34b3092df9fb4e2b8eac6dbb96}{Generic\+Reader}} (Stack\+Allocator $\ast$stack\+Allocator=0, size\+\_\+t stack\+Capacity=k\+Default\+Stack\+Capacity)
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
{\footnotesize template$<$unsigned parse\+Flags, typename Input\+Stream , typename Handler $>$ }\\\mbox{\hyperlink{struct_parse_result}{Parse\+Result}} \mbox{\hyperlink{class_generic_reader_a0c450620d14ff1824e58bb7bd9b42099}{Parse}} (Input\+Stream \&is, \mbox{\hyperlink{classrapidjson_1_1_handler}{Handler}} \&handler)
\begin{DoxyCompactList}\small\item\em Parse JSON text. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Input\+Stream , typename Handler $>$ }\\\mbox{\hyperlink{struct_parse_result}{Parse\+Result}} \mbox{\hyperlink{class_generic_reader_a76d91e5fd8dfe48aea7dd6d8a51dd6dc}{Parse}} (Input\+Stream \&is, \mbox{\hyperlink{classrapidjson_1_1_handler}{Handler}} \&handler)
\begin{DoxyCompactList}\small\item\em Parse JSON text (with \mbox{\hyperlink{reader_8h_ab7be7dabe6ffcba60fad441505583450a9104b0946d648e9467cb7a967401ec80}{k\+Parse\+Default\+Flags}}) \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_generic_reader_a7de472eda2ad9de13cfd8c1de74f1754}\label{class_generic_reader_a7de472eda2ad9de13cfd8c1de74f1754}} 
void \mbox{\hyperlink{class_generic_reader_a7de472eda2ad9de13cfd8c1de74f1754}{Iterative\+Parse\+Init}} ()
\begin{DoxyCompactList}\small\item\em Initialize JSON text token-\/by-\/token parsing. \end{DoxyCompactList}\item 
{\footnotesize template$<$unsigned parse\+Flags, typename Input\+Stream , typename Handler $>$ }\\bool \mbox{\hyperlink{class_generic_reader_a257891331e0c259903e7066fb4cebf92}{Iterative\+Parse\+Next}} (Input\+Stream \&is, \mbox{\hyperlink{classrapidjson_1_1_handler}{Handler}} \&handler)
\begin{DoxyCompactList}\small\item\em Parse one token from JSON text. \end{DoxyCompactList}\item 
RAPIDJSON\+\_\+\+FORCEINLINE bool \mbox{\hyperlink{class_generic_reader_aa1e9e1eef614fde971550ed2f955151d}{Iterative\+Parse\+Complete}} () const
\begin{DoxyCompactList}\small\item\em Check if token-\/by-\/token parsing JSON text is complete. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_generic_reader_ac417441794477ea747b63adb6d3653a9}\label{class_generic_reader_ac417441794477ea747b63adb6d3653a9}} 
bool \mbox{\hyperlink{class_generic_reader_ac417441794477ea747b63adb6d3653a9}{Has\+Parse\+Error}} () const
\begin{DoxyCompactList}\small\item\em Whether a parse error has occurred in the last parsing. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_generic_reader_a937bf90919f50e1c370b312cee5833e8}\label{class_generic_reader_a937bf90919f50e1c370b312cee5833e8}} 
\mbox{\hyperlink{group___r_a_p_i_d_j_s_o_n___e_r_r_o_r_s_ga8d4b32dfc45840bca189ade2bbcb6ba7}{Parse\+Error\+Code}} \mbox{\hyperlink{class_generic_reader_a937bf90919f50e1c370b312cee5833e8}{Get\+Parse\+Error\+Code}} () const
\begin{DoxyCompactList}\small\item\em Get the \mbox{\hyperlink{group___r_a_p_i_d_j_s_o_n___e_r_r_o_r_s_ga8d4b32dfc45840bca189ade2bbcb6ba7}{Parse\+Error\+Code}} of last parsing. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_generic_reader_ae9008523ccd06d839a57335835cb4091}\label{class_generic_reader_ae9008523ccd06d839a57335835cb4091}} 
size\+\_\+t \mbox{\hyperlink{class_generic_reader_ae9008523ccd06d839a57335835cb4091}{Get\+Error\+Offset}} () const
\begin{DoxyCompactList}\small\item\em Get the position of last parsing error in input, 0 otherwise. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_generic_reader_ae50079444295bf109730c3b708a818a6}\label{class_generic_reader_ae50079444295bf109730c3b708a818a6}} 
void {\bfseries Set\+Parse\+Error} (\mbox{\hyperlink{group___r_a_p_i_d_j_s_o_n___e_r_r_o_r_s_ga8d4b32dfc45840bca189ade2bbcb6ba7}{Parse\+Error\+Code}} code, size\+\_\+t offset)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename Source\+Encoding, typename Target\+Encoding, typename Stack\+Allocator = Crt\+Allocator$>$\newline
class Generic\+Reader$<$ Source\+Encoding, Target\+Encoding, Stack\+Allocator $>$}

SAX-\/style JSON parser. Use \mbox{\hyperlink{reader_8h_a84f3b66a66647f4ac4267078359188ba}{Reader}} for \mbox{\hyperlink{struct_u_t_f8}{UTF8}} encoding and default allocator. 

\mbox{\hyperlink{class_generic_reader}{Generic\+Reader}} parses JSON text from a stream, and send events synchronously to an object implementing Handler concept.

It needs to allocate a stack for storing a single decoded string during non-\/destructive parsing.

For in-\/situ parsing, the decoded string is directly written to the source text string, no temporary buffer is required.

A \mbox{\hyperlink{class_generic_reader}{Generic\+Reader}} object can be reused for parsing multiple JSON text.


\begin{DoxyTemplParams}{Template Parameters}
{\em Source\+Encoding} & Encoding of the input stream. \\
\hline
{\em Target\+Encoding} & Encoding of the parse output. \\
\hline
{\em Stack\+Allocator} & Allocator type for stack. \\
\hline
\end{DoxyTemplParams}


Definition at line 539 of file reader.\+h.



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_generic_reader_aab875a34b3092df9fb4e2b8eac6dbb96}\label{class_generic_reader_aab875a34b3092df9fb4e2b8eac6dbb96}} 
\index{GenericReader$<$ SourceEncoding, TargetEncoding, StackAllocator $>$@{GenericReader$<$ SourceEncoding, TargetEncoding, StackAllocator $>$}!GenericReader@{GenericReader}}
\index{GenericReader@{GenericReader}!GenericReader$<$ SourceEncoding, TargetEncoding, StackAllocator $>$@{GenericReader$<$ SourceEncoding, TargetEncoding, StackAllocator $>$}}
\doxysubsubsection{\texorpdfstring{GenericReader()}{GenericReader()}}
{\footnotesize\ttfamily template$<$typename Source\+Encoding , typename Target\+Encoding , typename Stack\+Allocator  = Crt\+Allocator$>$ \\
\mbox{\hyperlink{class_generic_reader}{Generic\+Reader}}$<$ Source\+Encoding, Target\+Encoding, Stack\+Allocator $>$\+::\mbox{\hyperlink{class_generic_reader}{Generic\+Reader}} (\begin{DoxyParamCaption}\item[{Stack\+Allocator $\ast$}]{stack\+Allocator = {\ttfamily 0},  }\item[{size\+\_\+t}]{stack\+Capacity = {\ttfamily kDefaultStackCapacity} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructor. 


\begin{DoxyParams}{Parameters}
{\em stack\+Allocator} & Optional allocator for allocating stack memory. (Only use for non-\/destructive parsing) \\
\hline
{\em stack\+Capacity} & stack capacity in bytes for storing a single decoded string. (Only use for non-\/destructive parsing) \\
\hline
\end{DoxyParams}


Definition at line 547 of file reader.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{547                                                                                                     :}
\DoxyCodeLine{548         stack\_(stackAllocator, stackCapacity), parseResult\_(), state\_(IterativeParsingStartState) \{\}}

\end{DoxyCode}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_generic_reader_aa1e9e1eef614fde971550ed2f955151d}\label{class_generic_reader_aa1e9e1eef614fde971550ed2f955151d}} 
\index{GenericReader$<$ SourceEncoding, TargetEncoding, StackAllocator $>$@{GenericReader$<$ SourceEncoding, TargetEncoding, StackAllocator $>$}!IterativeParseComplete@{IterativeParseComplete}}
\index{IterativeParseComplete@{IterativeParseComplete}!GenericReader$<$ SourceEncoding, TargetEncoding, StackAllocator $>$@{GenericReader$<$ SourceEncoding, TargetEncoding, StackAllocator $>$}}
\doxysubsubsection{\texorpdfstring{IterativeParseComplete()}{IterativeParseComplete()}}
{\footnotesize\ttfamily template$<$typename Source\+Encoding , typename Target\+Encoding , typename Stack\+Allocator  = Crt\+Allocator$>$ \\
RAPIDJSON\+\_\+\+FORCEINLINE bool \mbox{\hyperlink{class_generic_reader}{Generic\+Reader}}$<$ Source\+Encoding, Target\+Encoding, Stack\+Allocator $>$\+::Iterative\+Parse\+Complete (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Check if token-\/by-\/token parsing JSON text is complete. 

\begin{DoxyReturn}{Returns}
Whether the JSON has been fully decoded. 
\end{DoxyReturn}


Definition at line 677 of file reader.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{677                                                               \{}
\DoxyCodeLine{678         \textcolor{keywordflow}{return} IsIterativeParsingCompleteState(state\_);}
\DoxyCodeLine{679     \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_generic_reader_a257891331e0c259903e7066fb4cebf92}\label{class_generic_reader_a257891331e0c259903e7066fb4cebf92}} 
\index{GenericReader$<$ SourceEncoding, TargetEncoding, StackAllocator $>$@{GenericReader$<$ SourceEncoding, TargetEncoding, StackAllocator $>$}!IterativeParseNext@{IterativeParseNext}}
\index{IterativeParseNext@{IterativeParseNext}!GenericReader$<$ SourceEncoding, TargetEncoding, StackAllocator $>$@{GenericReader$<$ SourceEncoding, TargetEncoding, StackAllocator $>$}}
\doxysubsubsection{\texorpdfstring{IterativeParseNext()}{IterativeParseNext()}}
{\footnotesize\ttfamily template$<$typename Source\+Encoding , typename Target\+Encoding , typename Stack\+Allocator  = Crt\+Allocator$>$ \\
template$<$unsigned parse\+Flags, typename Input\+Stream , typename Handler $>$ \\
bool \mbox{\hyperlink{class_generic_reader}{Generic\+Reader}}$<$ Source\+Encoding, Target\+Encoding, Stack\+Allocator $>$\+::Iterative\+Parse\+Next (\begin{DoxyParamCaption}\item[{Input\+Stream \&}]{is,  }\item[{\mbox{\hyperlink{classrapidjson_1_1_handler}{Handler}} \&}]{handler }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Parse one token from JSON text. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Input\+Stream} & Type of input stream, implementing Stream concept \\
\hline
{\em Handler} & Type of handler, implementing Handler concept. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em is} & Input stream to be parsed. \\
\hline
{\em handler} & The handler to receive events. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Whether the parsing is successful. 
\end{DoxyReturn}


Definition at line 620 of file reader.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{620                                                                \{}
\DoxyCodeLine{621         \textcolor{keywordflow}{while} (\mbox{\hyperlink{group___r_a_p_i_d_j_s_o_n___c_o_n_f_i_g_ga5dc14176a9e71ace282404b0bcda57a1}{RAPIDJSON\_LIKELY}}(is.Peek() != \textcolor{charliteral}{'\(\backslash\)0'})) \{}
\DoxyCodeLine{622             SkipWhitespaceAndComments<parseFlags>(is);}
\DoxyCodeLine{623 }
\DoxyCodeLine{624             Token t = Tokenize(is.Peek());}
\DoxyCodeLine{625             IterativeParsingState n = Predict(state\_, t);}
\DoxyCodeLine{626             IterativeParsingState d = Transit<parseFlags>(state\_, t, n, is, handler);}
\DoxyCodeLine{627 }
\DoxyCodeLine{628             \textcolor{comment}{// If we've finished or hit an error...}}
\DoxyCodeLine{629             \textcolor{keywordflow}{if} (\mbox{\hyperlink{group___r_a_p_i_d_j_s_o_n___c_o_n_f_i_g_ga6a2b1695c13e77ae425e3cbac980ccb5}{RAPIDJSON\_UNLIKELY}}(IsIterativeParsingCompleteState(d))) \{}
\DoxyCodeLine{630                 \textcolor{comment}{// Report errors.}}
\DoxyCodeLine{631                 \textcolor{keywordflow}{if} (d == IterativeParsingErrorState) \{}
\DoxyCodeLine{632                     HandleError(state\_, is);}
\DoxyCodeLine{633                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{634                 \}}
\DoxyCodeLine{635 }
\DoxyCodeLine{636                 \textcolor{comment}{// Transition to the finish state.}}
\DoxyCodeLine{637                 \mbox{\hyperlink{group___r_a_p_i_d_j_s_o_n___c_o_n_f_i_g_gabeba18d612187bad2ac62aed9276d47c}{RAPIDJSON\_ASSERT}}(d == IterativeParsingFinishState);}
\DoxyCodeLine{638                 state\_ = d;}
\DoxyCodeLine{639 }
\DoxyCodeLine{640                 \textcolor{comment}{// If StopWhenDone is not set...}}
\DoxyCodeLine{641                 \textcolor{keywordflow}{if} (!(parseFlags \& \mbox{\hyperlink{reader_8h_ab7be7dabe6ffcba60fad441505583450af77d115d3bbed0a448b6b335f3b93b36}{kParseStopWhenDoneFlag}})) \{}
\DoxyCodeLine{642                     \textcolor{comment}{// ... and extra non-\/whitespace data is found...}}
\DoxyCodeLine{643                     SkipWhitespaceAndComments<parseFlags>(is);}
\DoxyCodeLine{644                     \textcolor{keywordflow}{if} (is.Peek() != \textcolor{charliteral}{'\(\backslash\)0'}) \{}
\DoxyCodeLine{645                         \textcolor{comment}{// ... this is considered an error.}}
\DoxyCodeLine{646                         HandleError(state\_, is);}
\DoxyCodeLine{647                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{648                     \}}
\DoxyCodeLine{649                 \}}
\DoxyCodeLine{650 }
\DoxyCodeLine{651                 \textcolor{comment}{// Success! We are done!}}
\DoxyCodeLine{652                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{653             \}}
\DoxyCodeLine{654 }
\DoxyCodeLine{655             \textcolor{comment}{// Transition to the new state.}}
\DoxyCodeLine{656             state\_ = d;}
\DoxyCodeLine{657 }
\DoxyCodeLine{658             \textcolor{comment}{// If we parsed anything other than a delimiter, we invoked the handler, so we can return true now.}}
\DoxyCodeLine{659             \textcolor{keywordflow}{if} (!IsIterativeParsingDelimiterState(n))}
\DoxyCodeLine{660                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{661         \}}
\DoxyCodeLine{662 }
\DoxyCodeLine{663         \textcolor{comment}{// We reached the end of file.}}
\DoxyCodeLine{664         stack\_.Clear();}
\DoxyCodeLine{665 }
\DoxyCodeLine{666         \textcolor{keywordflow}{if} (state\_ != IterativeParsingFinishState) \{}
\DoxyCodeLine{667             HandleError(state\_, is);}
\DoxyCodeLine{668             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{669         \}}
\DoxyCodeLine{670 }
\DoxyCodeLine{671         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{672     \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_generic_reader_a0c450620d14ff1824e58bb7bd9b42099}\label{class_generic_reader_a0c450620d14ff1824e58bb7bd9b42099}} 
\index{GenericReader$<$ SourceEncoding, TargetEncoding, StackAllocator $>$@{GenericReader$<$ SourceEncoding, TargetEncoding, StackAllocator $>$}!Parse@{Parse}}
\index{Parse@{Parse}!GenericReader$<$ SourceEncoding, TargetEncoding, StackAllocator $>$@{GenericReader$<$ SourceEncoding, TargetEncoding, StackAllocator $>$}}
\doxysubsubsection{\texorpdfstring{Parse()}{Parse()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Source\+Encoding , typename Target\+Encoding , typename Stack\+Allocator  = Crt\+Allocator$>$ \\
template$<$unsigned parse\+Flags, typename Input\+Stream , typename Handler $>$ \\
\mbox{\hyperlink{struct_parse_result}{Parse\+Result}} \mbox{\hyperlink{class_generic_reader}{Generic\+Reader}}$<$ Source\+Encoding, Target\+Encoding, Stack\+Allocator $>$\+::Parse (\begin{DoxyParamCaption}\item[{Input\+Stream \&}]{is,  }\item[{\mbox{\hyperlink{classrapidjson_1_1_handler}{Handler}} \&}]{handler }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Parse JSON text. 


\begin{DoxyTemplParams}{Template Parameters}
{\em parse\+Flags} & Combination of \mbox{\hyperlink{reader_8h_ab7be7dabe6ffcba60fad441505583450}{Parse\+Flag}}. \\
\hline
{\em Input\+Stream} & Type of input stream, implementing Stream concept. \\
\hline
{\em Handler} & Type of handler, implementing Handler concept. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em is} & Input stream to be parsed. \\
\hline
{\em handler} & The handler to receive events. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Whether the parsing is successful. 
\end{DoxyReturn}


Definition at line 559 of file reader.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{559                                                          \{}
\DoxyCodeLine{560         \textcolor{keywordflow}{if} (parseFlags \& \mbox{\hyperlink{reader_8h_ab7be7dabe6ffcba60fad441505583450aadb14f5a3b6b33e28055e913a2eae5e9}{kParseIterativeFlag}})}
\DoxyCodeLine{561             \textcolor{keywordflow}{return} IterativeParse<parseFlags>(is, handler);}
\DoxyCodeLine{562 }
\DoxyCodeLine{563         parseResult\_.\mbox{\hyperlink{struct_parse_result_a88b6d44f052a19e6436ae6aadc2c40b4}{Clear}}();}
\DoxyCodeLine{564 }
\DoxyCodeLine{565         ClearStackOnExit scope(*\textcolor{keyword}{this});}
\DoxyCodeLine{566 }
\DoxyCodeLine{567         SkipWhitespaceAndComments<parseFlags>(is);}
\DoxyCodeLine{568         RAPIDJSON\_PARSE\_ERROR\_EARLY\_RETURN(parseResult\_);}
\DoxyCodeLine{569 }
\DoxyCodeLine{570         \textcolor{keywordflow}{if} (\mbox{\hyperlink{group___r_a_p_i_d_j_s_o_n___c_o_n_f_i_g_ga6a2b1695c13e77ae425e3cbac980ccb5}{RAPIDJSON\_UNLIKELY}}(is.Peek() == \textcolor{charliteral}{'\(\backslash\)0'})) \{}
\DoxyCodeLine{571             \mbox{\hyperlink{group___r_a_p_i_d_j_s_o_n___e_r_r_o_r_s_ga7f8c4265b2edda78568ae3338aaf1461}{RAPIDJSON\_PARSE\_ERROR\_NORETURN}}(\mbox{\hyperlink{group___r_a_p_i_d_j_s_o_n___e_r_r_o_r_s_gga8d4b32dfc45840bca189ade2bbcb6ba7a04b368d184e84b50580be2faa55f738a}{kParseErrorDocumentEmpty}}, is.Tell());}
\DoxyCodeLine{572             RAPIDJSON\_PARSE\_ERROR\_EARLY\_RETURN(parseResult\_);}
\DoxyCodeLine{573         \}}
\DoxyCodeLine{574         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{575             ParseValue<parseFlags>(is, handler);}
\DoxyCodeLine{576             RAPIDJSON\_PARSE\_ERROR\_EARLY\_RETURN(parseResult\_);}
\DoxyCodeLine{577 }
\DoxyCodeLine{578             \textcolor{keywordflow}{if} (!(parseFlags \& \mbox{\hyperlink{reader_8h_ab7be7dabe6ffcba60fad441505583450af77d115d3bbed0a448b6b335f3b93b36}{kParseStopWhenDoneFlag}})) \{}
\DoxyCodeLine{579                 SkipWhitespaceAndComments<parseFlags>(is);}
\DoxyCodeLine{580                 RAPIDJSON\_PARSE\_ERROR\_EARLY\_RETURN(parseResult\_);}
\DoxyCodeLine{581 }
\DoxyCodeLine{582                 \textcolor{keywordflow}{if} (\mbox{\hyperlink{group___r_a_p_i_d_j_s_o_n___c_o_n_f_i_g_ga6a2b1695c13e77ae425e3cbac980ccb5}{RAPIDJSON\_UNLIKELY}}(is.Peek() != \textcolor{charliteral}{'\(\backslash\)0'})) \{}
\DoxyCodeLine{583                     \mbox{\hyperlink{group___r_a_p_i_d_j_s_o_n___e_r_r_o_r_s_ga7f8c4265b2edda78568ae3338aaf1461}{RAPIDJSON\_PARSE\_ERROR\_NORETURN}}(\mbox{\hyperlink{group___r_a_p_i_d_j_s_o_n___e_r_r_o_r_s_gga8d4b32dfc45840bca189ade2bbcb6ba7a2293b39033220f4c2a568482c497dab5}{kParseErrorDocumentRootNotSingular}}, is.Tell());}
\DoxyCodeLine{584                     RAPIDJSON\_PARSE\_ERROR\_EARLY\_RETURN(parseResult\_);}
\DoxyCodeLine{585                 \}}
\DoxyCodeLine{586             \}}
\DoxyCodeLine{587         \}}
\DoxyCodeLine{588 }
\DoxyCodeLine{589         \textcolor{keywordflow}{return} parseResult\_;}
\DoxyCodeLine{590     \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_generic_reader_a76d91e5fd8dfe48aea7dd6d8a51dd6dc}\label{class_generic_reader_a76d91e5fd8dfe48aea7dd6d8a51dd6dc}} 
\index{GenericReader$<$ SourceEncoding, TargetEncoding, StackAllocator $>$@{GenericReader$<$ SourceEncoding, TargetEncoding, StackAllocator $>$}!Parse@{Parse}}
\index{Parse@{Parse}!GenericReader$<$ SourceEncoding, TargetEncoding, StackAllocator $>$@{GenericReader$<$ SourceEncoding, TargetEncoding, StackAllocator $>$}}
\doxysubsubsection{\texorpdfstring{Parse()}{Parse()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Source\+Encoding , typename Target\+Encoding , typename Stack\+Allocator  = Crt\+Allocator$>$ \\
template$<$typename Input\+Stream , typename Handler $>$ \\
\mbox{\hyperlink{struct_parse_result}{Parse\+Result}} \mbox{\hyperlink{class_generic_reader}{Generic\+Reader}}$<$ Source\+Encoding, Target\+Encoding, Stack\+Allocator $>$\+::Parse (\begin{DoxyParamCaption}\item[{Input\+Stream \&}]{is,  }\item[{\mbox{\hyperlink{classrapidjson_1_1_handler}{Handler}} \&}]{handler }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Parse JSON text (with \mbox{\hyperlink{reader_8h_ab7be7dabe6ffcba60fad441505583450a9104b0946d648e9467cb7a967401ec80}{k\+Parse\+Default\+Flags}}) 


\begin{DoxyTemplParams}{Template Parameters}
{\em Input\+Stream} & Type of input stream, implementing Stream concept \\
\hline
{\em Handler} & Type of handler, implementing Handler concept. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em is} & Input stream to be parsed. \\
\hline
{\em handler} & The handler to receive events. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Whether the parsing is successful. 
\end{DoxyReturn}


Definition at line 600 of file reader.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{600                                                          \{}
\DoxyCodeLine{601         \textcolor{keywordflow}{return} Parse<kParseDefaultFlags>(is, handler);}
\DoxyCodeLine{602     \}}

\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/rapidjson/fwd.\+h\item 
src/rapidjson/\mbox{\hyperlink{reader_8h}{reader.\+h}}\end{DoxyCompactItemize}
